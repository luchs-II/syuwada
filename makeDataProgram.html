<!DOCTYPE html>
<html>
<head>

  <style type="text/css">

    ::-webkit-scrollbar {
      width: 7px;
      height: 7px;
    }

    ::-webkit-scrollbar-thumb {
      background: #666666;
      border-radius: 3px;
    }

    #listBox {
      width: 20%;
      height: 30%;
      background-color: #ffffff;
      border: 1px #c0c0c0 solid;
      color: #000000;
      overflow: auto;
      white-space:nowrap;
      position: absolute;
      top: 40%;
      right: 1.5%;
      border-radius: 5px;
      line-height: 3px;
    }

  </style>

  <meta charset="utf-8">
  <!--media pipe: 手の骨格取得や認識結果の描画に使用-->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  <!--opencv.js: 手の傾きや中心位置を計算するために使用-->
  <script src="https://docs.opencv.org/3.4.1/opencv.js"></script>

  <!--今回のハンズオンで行う処理を記述-->
  <script type="text/javascript">


    let isPressSpace = false;   //スペースキーが押されたか？
    let canvasElement;          //canvas
    let canvasCtx;              //ctx
    let landmarksList = [];
    const gain = 0.1;
    let charNum = 0;  //"あ"
    const allMoji = "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよわをん";


    //初期化
    window.onload = function() {
      //画像の読み込み
      beam = document.getElementById("beam");           
      //ビデオ要素の取得
      let videoElement = document.getElementById('input_video');
      //表示用のCanvasを取得
      canvasElement = document.getElementById('output_canvas');
      //Canvas描画に関する情報にアクセス
      canvasCtx = canvasElement.getContext('2d');
      //HandTrackingを使用するための関連ファイルの取得と初期化
      const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
      }});
      //手の認識に関するオプション
      hands.setOptions({
        selfieMode:false,  //画像を左右反転
        maxNumHands: 1, //認識可能な手の最大数
        modelComplexity: 1,//精度に関する設定(0~1)
        minDetectionConfidence: 0.5,//手検出の信頼度
        minTrackingConfidence: 0.5,//手追跡の信頼度
        useCpuInference: false, //M1 MacのSafariの場合はtrue
      });
       //結果を処理する関数を登録
      hands.onResults(recvResults);
      //カメラの初期化
      const camera = new Camera(videoElement, {
        onFrame: async () => {
          //カメラの画像を用いて手の検出を実行
          await hands.send({image: videoElement});
        },
        width: 1280, height: 720
      });
      //カメラの動作開始
      camera.start();
    };


    //手の検出結果を利用する
    function recvResults(results) {

      const winWidth = window.outerWidth * 0.76;
      const winHeight = window.outerHeight * 0.76;

      //canvasの大きさをウィンドウサイズに合わせる。
      canvasElement.width = winWidth;
      canvasElement.height = winHeight;


      //以下、canvasへの描画に関する記述
      canvasCtx.save();
      //画像を表示
      canvasCtx.drawImage(results.image, 0, 0, winWidth, winHeight);
      // console.log(results.image);

      //手を検出したならばtrue
      if (results.multiHandLandmarks.length != 0) {

        //見つけた手の数だけ処理を繰り返す
        for (const landmarks of results.multiHandLandmarks) {
          //骨格を描画
          drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS,{color: '#00FF00', lineWidth: 2});
          //関節を描画
          drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1,radius:2});

          //スペースキーが押されたら...
          if(isPressSpace == true){
            const normalizedPoint = saveResults(landmarks, gain, results.image, canvasElement);
            landmarksList.push(charNum + ',' + normalizedPoint);

            //以下で関節データをリストに追加

            const listBox = document.getElementById('listBox');
            //リストアイテムを挿入
            listBox.insertAdjacentHTML('beforeend', '<p>' + allMoji[charNum] + ' = ' + normalizedPoint + '</p>');
            //スクロールバーの位置をリストの最下部に設定
            listBox.scrollTo(0, listBox.scrollHeight);
          }
        }
      }

      isPressSpace = false;
      canvasCtx.restore();
    }

    //主に結果の整理や保存をする関数
    function saveResults(landmarks, gain, resultImg, beforeTrimImg){

      let point = new Object(),
          len = new Object(), 
          offset = new Object(),
          len_whithMargin,
          normalizedPoint;

      const width = resultImg.width;
      const height = resultImg.height;
      const xarray = landmarks.map(p => p.x * width); //landmarksから、x座標のみの配列を作成
      const yarray = landmarks.map(p => p.y * height); //landmarksから、y座標のみの配列を作成

      point.x1 = Math.min(...xarray);  //xの最小値を求める。
      point.x2 = Math.max(...xarray);  //xの最大値を求める。
      point.y1 = Math.min(...yarray);  //yの最小値を求める。
      point.y2 = Math.max(...yarray);  //yの最大値を求める。

      len.x = point.x2 - point.x1;
      len.y = point.y2 - point.y1;

      len_whithMargin = Math.max(len.x, len.y) * (gain + 1);

      offset.x = point.x1 - ((len_whithMargin - len.x) / 2);
      offset.y = point.y1 - ((len_whithMargin - len.y) / 2);



      normalizedPoint = landmarks.map(p => [(p.x * width - offset.x) / len_whithMargin,
                                            (p.y * height - offset.y) / len_whithMargin,
                                            p.z]);

      // console.log(len_whithMargin);
      // console.table(normalizedPoint);


      //以下で画像をトリミング
      
      const trimImg = document.createElement('canvas');
      const trimImg_ctx = trimImg.getContext('2d');
      trimImg.width = len_whithMargin;
      trimImg.height = len_whithMargin;

      const sizeRateX = beforeTrimImg.width / width;
      const sizeRateY = beforeTrimImg.height / height;

      trimImg_ctx.drawImage(beforeTrimImg,
                            offset.x * sizeRateX,
                            offset.y * sizeRateY,
                            len_whithMargin * sizeRateX,
                            len_whithMargin * sizeRateY,
                            0, 0, len_whithMargin, len_whithMargin);


      //以下でトリミングした画像をダウンロードする

      var a = document.createElement('a');
      //canvasをJPEG変換し、そのBase64文字列をhrefへセット
      a.href = trimImg.toDataURL('image/jpeg', 0.85);
      //ダウンロード時のファイル名を指定
      a.download = 'pointData_trimImg -.jpg';
      //クリックイベントを発生させる
      a.click();

      return normalizedPoint;   //csv用のデータを返す。


      //以下、.CSVをダウンロードするプログラム

      const blob = new Blob(normalizedPoint, { type: "text/csv" });

      //BlobからオブジェクトURLを作成する
      const url = (window.URL || window.webkitURL).createObjectURL(blob);
      //ダウンロード用にリンクを作成する
      const download = document.createElement("a");
      //リンク先に上記で生成したURLを指定する
      download.href = url;
      //download属性にファイル名を指定する
      download.download = "pointData.csv";
      //作成したリンクをクリックしてダウンロードを実行する
      download.click();
      //createObjectURLで作成したオブジェクトURLを開放する
      (window.URL || window.webkitURL).revokeObjectURL(url);

    }

    //スペースキーが押されたときに反応する
    document.addEventListener('keypress', (event) => {
      if (event.code === "Space" && isPressSpace == false){
        isPressSpace = true;
      }
    });

  </script>
</head>

<body>
    <video id="input_video" style="position:absolute; display:none;"></video>
    <img id="beam" src="https://cdn.glitch.me/ad9fef5c-efc6-4637-81e8-6db3270ffc22%2Fbeam.png?v=1635160767213" style="position:absolute; display:none;">
    <canvas id="output_canvas" style="position:absolute;"></canvas>


    <div id="listBox">
      <p>ここに関節データが表示されます...</p>
      <p>手を映してからスペースキーを押して撮影...</p>
    </div>
</body>
</html>

